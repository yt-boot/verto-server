package com.verto.modules.pipeline.service.impl;

import com.verto.modules.pipeline.dto.PipelineCreateRequest;
import com.verto.modules.pipeline.dto.PipelineDefinitionRequest;
import com.verto.modules.pipeline.service.IJenkinsService;
import com.verto.modules.pipeline.config.JenkinsProperties;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.util.UriComponentsBuilder;

import java.nio.charset.StandardCharsets;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.stream.Collectors;

@Service
@Slf4j
public class JenkinsServiceImpl implements IJenkinsService {

    @Autowired
    private JenkinsProperties jenkinsProperties;

    private RestTemplate restTemplate = new RestTemplate();

    private HttpHeaders buildAuthHeaders() {
        String auth = jenkinsProperties.getUser() + ":" + jenkinsProperties.getToken();
        String encodedAuth = Base64.getEncoder().encodeToString(auth.getBytes(StandardCharsets.UTF_8));
        HttpHeaders headers = new HttpHeaders();
        headers.set("Authorization", "Basic " + encodedAuth);
        headers.setContentType(MediaType.APPLICATION_XML);
        return headers;
    }

    private HttpHeaders buildFormAuthHeaders() {
        String auth = jenkinsProperties.getUser() + ":" + jenkinsProperties.getToken();
        String encodedAuth = Base64.getEncoder().encodeToString(auth.getBytes(StandardCharsets.UTF_8));
        HttpHeaders headers = new HttpHeaders();
        headers.set("Authorization", "Basic " + encodedAuth);
        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);
        return headers;
    }

    private Map<String, String> getCrumb() {
        try {
            String url = jenkinsProperties.getUrl() + "/crumbIssuer/api/json";
            HttpEntity<Void> entity = new HttpEntity<>(buildAuthHeaders());
            ResponseEntity<Map> resp = restTemplate.exchange(url, HttpMethod.GET, entity, Map.class);
            Map<String, String> result = new HashMap<>();
            if (resp.getStatusCode().is2xxSuccessful() && resp.getBody() != null) {
                Object field = resp.getBody().get("crumbRequestField");
                Object crumb = resp.getBody().get("crumb");
                if (field != null && crumb != null) {
                    result.put("field", field.toString());
                    result.put("crumb", crumb.toString());
                }
            }
            return result;
        } catch (Exception e) {
            log.warn("Failed to fetch Jenkins crumb, CSRF may be disabled: {}", e.getMessage());
            return new HashMap<>();
        }
    }

    // 将 jobExists 公开并实现接口方法
    @Override
    public boolean jobExists(String jobName) {
        try {
            String url = jenkinsProperties.getUrl() + "/job/" + jobName + "/config.xml";
            HttpEntity<Void> entity = new HttpEntity<>(buildAuthHeaders());
            ResponseEntity<String> resp = restTemplate.exchange(url, HttpMethod.GET, entity, String.class);
            return resp.getStatusCode().is2xxSuccessful();
        } catch (HttpClientErrorException.NotFound e) {
            return false;
        } catch (Exception e) {
            log.error("Check job exists error: {}", e.getMessage());
            return false;
        }
    }

    private String buildConfigXml(PipelineCreateRequest req) {
        if (req.isUseInlineScript() && StringUtils.hasText(req.getPipelineScript())) {
            String scriptEscaped = req.getPipelineScript()
                    .replace("&", "&amp;")
                    .replace("<", "&lt;")
                    .replace(">", "&gt;");
            return "" +
                    "<?xml version=\"1.1\" encoding=\"UTF-8\"?>\n" +
                    "<flow-definition plugin=\"workflow-job\">\n" +
                    "  <description>Generated by Verto</description>\n" +
                    "  <keepDependencies>false</keepDependencies>\n" +
                    // 定义参数（分支、提交ID）以支持参数化构建
                    "  <properties>\n" +
                    "    <hudson.model.ParametersDefinitionProperty>\n" +
                    "      <parameterDefinitions>\n" +
                    "        <hudson.model.StringParameterDefinition>\n" +
                    "          <name>BRANCH</name>\n" +
                    "          <description>需要构建的Git分支</description>\n" +
                    "          <defaultValue>" + (StringUtils.hasText(req.getBranch()) ? req.getBranch() : "main") + "</defaultValue>\n" +
                    "          <trim>true</trim>\n" +
                    "        </hudson.model.StringParameterDefinition>\n" +
                    "        <hudson.model.StringParameterDefinition>\n" +
                    "          <name>COMMIT_ID</name>\n" +
                    "          <description>指定提交哈希(可选)</description>\n" +
                    "          <defaultValue></defaultValue>\n" +
                    "          <trim>true</trim>\n" +
                    "        </hudson.model.StringParameterDefinition>\n" +
                    "      </parameterDefinitions>\n" +
                    "    </hudson.model.ParametersDefinitionProperty>\n" +
                    "  </properties>\n" +
                    "  <definition class=\"org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition\" plugin=\"workflow-cps\">\n" +
                    "    <script>" + scriptEscaped + "</script>\n" +
                    "    <sandbox>true</sandbox>\n" +
                    "  </definition>\n" +
                    "  <triggers/>\n" +
                    "  <disabled>false</disabled>\n" +
                    "</flow-definition>\n";
        }

        // Default: use SCM Jenkinsfile
        String repoUrl = req.getRepoUrl();
        // 将分支改为可参数化，优先使用运行参数 BRANCH；默认值仍采用请求中的分支或 main
        String defaultBranch = StringUtils.hasText(req.getBranch()) ? req.getBranch() : "main";
        String credentialsId = req.getCredentialsId();
        String scriptPath = StringUtils.hasText(req.getJenkinsfilePath()) ? req.getJenkinsfilePath() : "Jenkinsfile";

        return "" +
                "<?xml version=\"1.1\" encoding=\"UTF-8\"?>\n" +
                "<flow-definition plugin=\"workflow-job\">\n" +
                "  <description>Generated by Verto</description>\n" +
                "  <keepDependencies>false</keepDependencies>\n" +
                // 定义参数（分支、提交ID）以支持参数化构建
                "  <properties>\n" +
                "    <hudson.model.ParametersDefinitionProperty>\n" +
                "      <parameterDefinitions>\n" +
                "        <hudson.model.StringParameterDefinition>\n" +
                "          <name>BRANCH</name>\n" +
                "          <description>需要构建的Git分支</description>\n" +
                "          <defaultValue>" + defaultBranch + "</defaultValue>\n" +
                "          <trim>true</trim>\n" +
                "        </hudson.model.StringParameterDefinition>\n" +
                "        <hudson.model.StringParameterDefinition>\n" +
                "          <name>COMMIT_ID</name>\n" +
                "          <description>指定提交哈希(可选)</description>\n" +
                "          <defaultValue></defaultValue>\n" +
                "          <trim>true</trim>\n" +
                "        </hudson.model.StringParameterDefinition>\n" +
                "      </parameterDefinitions>\n" +
                "    </hudson.model.ParametersDefinitionProperty>\n" +
                "  </properties>\n" +
                "  <definition class=\"org.jenkinsci.plugins.workflow.cps.CpsScmFlowDefinition\" plugin=\"workflow-cps\">\n" +
                "    <scm class=\"hudson.plugins.git.GitSCM\" plugin=\"git\">\n" +
                "      <configVersion>2</configVersion>\n" +
                "      <userRemoteConfigs>\n" +
                "        <hudson.plugins.git.UserRemoteConfig>\n" +
                "          <url>" + repoUrl + "</url>\n" +
                (StringUtils.hasText(credentialsId) ? "          <credentialsId>" + credentialsId + "</credentialsId>\n" : "") +
                "        </hudson.plugins.git.UserRemoteConfig>\n" +
                "      </userRemoteConfigs>\n" +
                "      <branches>\n" +
                "        <hudson.plugins.git.BranchSpec>\n" +
                // 使用参数化分支 spec；Git 插件支持环境变量替换
                "          <name>*/${BRANCH}</name>\n" +
                "        </hudson.plugins.git.BranchSpec>\n" +
                "      </branches>\n" +
                "      <doGenerateSubmoduleConfigurations>false</doGenerateSubmoduleConfigurations>\n" +
                "      <submoduleCfg class=\"list\"/>\n" +
                "      <extensions/>\n" +
                "    </scm>\n" +
                "    <scriptPath>" + scriptPath + "</scriptPath>\n" +
                "    <lightweight>true</lightweight>\n" +
                "  </definition>\n" +
                "  <triggers/>\n" +
                "  <disabled>false</disabled>\n" +
                "</flow-definition>\n";
    }

    /**
     * 根据生成的 Jenkinsfile 组装 CpsFlowDefinition 的 config.xml
     */
    private String buildInlineConfigXml(String script) {
        String scriptEscaped = script
                .replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;");
        return "" +
                "<?xml version=\"1.1\" encoding=\"UTF-8\"?>\n" +
                "<flow-definition plugin=\"workflow-job\">\n" +
                "  <description>Generated by Verto</description>\n" +
                "  <keepDependencies>false</keepDependencies>\n" +
                // 定义参数（分支、提交ID）以支持参数化构建
                "  <properties>\n" +
                "    <hudson.model.ParametersDefinitionProperty>\n" +
                "      <parameterDefinitions>\n" +
                "        <hudson.model.StringParameterDefinition>\n" +
                "          <name>BRANCH</name>\n" +
                "          <description>需要构建的Git分支</description>\n" +
                "          <defaultValue>main</defaultValue>\n" +
                "          <trim>true</trim>\n" +
                "        </hudson.model.StringParameterDefinition>\n" +
                "        <hudson.model.StringParameterDefinition>\n" +
                "          <name>COMMIT_ID</name>\n" +
                "          <description>指定提交哈希(可选)</description>\n" +
                "          <defaultValue></defaultValue>\n" +
                "          <trim>true</trim>\n" +
                "        </hudson.model.StringParameterDefinition>\n" +
                "      </parameterDefinitions>\n" +
                "    </hudson.model.ParametersDefinitionProperty>\n" +
                "  </properties>\n" +
                "  <definition class=\"org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition\" plugin=\"workflow-cps\">\n" +
                "    <script>" + scriptEscaped + "</script>\n" +
                "    <sandbox>true</sandbox>\n" +
                "  </definition>\n" +
                "  <triggers/>\n" +
                "  <disabled>false</disabled>\n" +
                "</flow-definition>\n";
    }

    /**
     * 将完整配置转换为 Declarative Jenkinsfile
     */
    private String generateJenkinsfile(PipelineDefinitionRequest req) {
        StringBuilder sb = new StringBuilder();
        sb.append("pipeline {\n");

        // agent
        if (req.getAgentLabel() != null && !req.getAgentLabel().isEmpty()) {
            sb.append("  agent { label '" + req.getAgentLabel() + "' }\n");
        } else {
            sb.append("  agent any\n");
        }

        // environment
        if (req.getVariables() != null && !req.getVariables().isEmpty()) {
            sb.append("  environment {\n");
            for (Map.Entry<String, String> e : req.getVariables().entrySet()) {
                String key = e.getKey();
                String val = e.getValue() == null ? "" : e.getValue();
                // 单引号包裹，避免特殊字符
                sb.append("    ").append(key).append(" = '").append(val.replace("'", "'\\''")).append("'\n");
            }
            sb.append("  }\n");
        }

        // triggers
        PipelineDefinitionRequest.Triggers triggers = req.getTriggers();
        if (triggers != null && ((triggers.getCron() != null && !triggers.getCron().isEmpty()) || Boolean.TRUE.equals(triggers.getPollScm()))) {
            sb.append("  triggers {\n");
            if (triggers.getCron() != null && !triggers.getCron().isEmpty()) {
                sb.append("    cron('" + triggers.getCron() + "')\n");
            }
            if (Boolean.TRUE.equals(triggers.getPollScm())) {
                // 默认每 15 分钟轮询，可根据需要调整或从前端传入表达式
                sb.append("    pollSCM('H/15 * * * *')\n");
            }
            sb.append("  }\n");
        }

        // stages
        List<PipelineDefinitionRequest.Stage> stages = req.getStages();
        sb.append("  stages {\n");
        if (stages != null) {
            for (PipelineDefinitionRequest.Stage st : stages) {
                String stageName = (st.getDisplayName() != null && !st.getDisplayName().isEmpty()) ? st.getDisplayName() : st.getName();
                sb.append("    stage('" + stageName + "') {\n");
                // stage options
                if (st.getTimeoutSeconds() != null && st.getTimeoutSeconds() > 0) {
                    sb.append("      options { timeout(time: ").append(st.getTimeoutSeconds()).append(", unit: 'SECONDS') }\n");
                }
                sb.append("      steps {\n");
                if (st.getCommands() != null && !st.getCommands().isEmpty()) {
                    for (String cmd : st.getCommands()) {
                        String safeCmd = cmd == null ? "" : cmd;
                        sb.append("        sh '" + safeCmd.replace("'", "'\\''") + "'\n");
                    }
                } else {
                    sb.append("        echo 'No commands provided'\n");
                }
                sb.append("      }\n");
                sb.append("    }\n");
            }
        }
        sb.append("  }\n");

        sb.append("}\n");
        return sb.toString();
    }

    @Override
    public Map<String, Object> createPipelineJobFromDefinition(PipelineDefinitionRequest request) {
        Map<String, Object> result = new HashMap<>();
        String jobName = request.getJobName();
        String jenkinsfile = generateJenkinsfile(request);
        String configXml = buildInlineConfigXml(jenkinsfile);

        // Prepare headers with auth and crumb
        HttpHeaders headers = buildAuthHeaders();
        Map<String, String> crumb = getCrumb();
        if (crumb.containsKey("field") && crumb.containsKey("crumb")) {
            headers.set(crumb.get("field"), crumb.get("crumb"));
        }

        HttpEntity<String> entity = new HttpEntity<>(configXml, headers);

        try {
            if (jobExists(jobName)) {
                // Update existing job
                String url = jenkinsProperties.getUrl() + "/job/" + jobName + "/config.xml";
                ResponseEntity<String> resp = restTemplate.exchange(url, HttpMethod.POST, entity, String.class);
                result.put("action", "updated");
                result.put("status", resp.getStatusCodeValue());
                result.put("jobUrl", jenkinsProperties.getUrl() + "/job/" + jobName + "/");
            } else {
                // Create new job
                String url = UriComponentsBuilder.fromHttpUrl(jenkinsProperties.getUrl() + "/createItem")
                        .queryParam("name", jobName)
                        .toUriString();
                ResponseEntity<String> resp = restTemplate.exchange(url, HttpMethod.POST, entity, String.class);
                result.put("action", "created");
                result.put("status", resp.getStatusCodeValue());
                result.put("jobUrl", jenkinsProperties.getUrl() + "/job/" + jobName + "/");
            }
        } catch (Exception e) {
            log.error("Failed to create/update Jenkins job from definition: {}", e.getMessage());
            result.put("error", e.getMessage());
        }

        return result;
    }

    @Override
    public Map<String, Object> createOrUpdatePipelineJob(PipelineCreateRequest request) {
        Map<String, Object> result = new HashMap<>();
        String jobName = request.getJobName();
        String configXml = buildConfigXml(request);

        // Prepare headers with auth and crumb
        HttpHeaders headers = buildAuthHeaders();
        Map<String, String> crumb = getCrumb();
        if (crumb.containsKey("field") && crumb.containsKey("crumb")) {
            headers.set(crumb.get("field"), crumb.get("crumb"));
        }

        HttpEntity<String> entity = new HttpEntity<>(configXml, headers);

        try {
            if (jobExists(jobName)) {
                // Update existing job
                String url = jenkinsProperties.getUrl() + "/job/" + jobName + "/config.xml";
                ResponseEntity<String> resp = restTemplate.exchange(url, HttpMethod.POST, entity, String.class);
                result.put("action", "updated");
                result.put("status", resp.getStatusCodeValue());
                result.put("jobUrl", jenkinsProperties.getUrl() + "/job/" + jobName + "/");
            } else {
                // Create new job
                String url = UriComponentsBuilder.fromHttpUrl(jenkinsProperties.getUrl() + "/createItem")
                        .queryParam("name", jobName)
                        .toUriString();
                ResponseEntity<String> resp = restTemplate.exchange(url, HttpMethod.POST, entity, String.class);
                result.put("action", "created");
                result.put("status", resp.getStatusCodeValue());
                result.put("jobUrl", jenkinsProperties.getUrl() + "/job/" + jobName + "/");
            }
        } catch (Exception e) {
            log.error("Failed to create/update Jenkins job: {}", e.getMessage());
            result.put("error", e.getMessage());
        }

        return result;
    }

    @Override
    public Map<String, Object> triggerBuild(String jobName, Map<String, String> parameters) {
        Map<String, Object> result = new HashMap<>();

        try {
            if (!jobExists(jobName)) {
                result.put("error", "Job not found: " + jobName);
                return result;
            }

            // Prepare headers with auth and crumb
            HttpHeaders headers = buildFormAuthHeaders();
            Map<String, String> crumb = getCrumb();
            if (crumb.containsKey("field") && crumb.containsKey("crumb")) {
                headers.set(crumb.get("field"), crumb.get("crumb"));
            }

            MultiValueMap<String, String> form = new LinkedMultiValueMap<>();
            if (parameters != null) {
                parameters.forEach((k, v) -> {
                    if (v != null) {
                        form.add(k, v);
                    }
                });
            }

            HttpEntity<MultiValueMap<String, String>> entity = new HttpEntity<>(form, headers);

            String url = jenkinsProperties.getUrl() + "/job/" + jobName + "/" + (form.isEmpty() ? "build" : "buildWithParameters");
            ResponseEntity<String> resp = restTemplate.exchange(url, HttpMethod.POST, entity, String.class);

            // Jenkins returns 201 Created with Location header pointing to queue item
            String location = resp.getHeaders().getFirst("Location");
            result.put("statusCode", resp.getStatusCodeValue());
            result.put("jobUrl", jenkinsProperties.getUrl() + "/job/" + jobName + "/");
            if (location != null) {
                result.put("queueUrl", location);
                // Extract queueId if possible
                try {
                    String trimmed = location.endsWith("/") ? location.substring(0, location.length() - 1) : location;
                    int idx = trimmed.lastIndexOf('/');
                    if (idx > 0) {
                        String qid = trimmed.substring(idx + 1);
                        if (qid.matches("\\d+")) {
                            result.put("queueId", qid);
                        }
                    }
                } catch (Exception ignore) {}
            }
        } catch (Exception e) {
            log.error("Failed to trigger Jenkins build for job {}: {}", jobName, e.getMessage());
            result.put("error", e.getMessage());
        }

        return result;
    }
}